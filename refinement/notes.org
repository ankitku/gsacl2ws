<2023-06-24 Sat>
- if i can prove a refinement between records and synth table, then
  horizontal ref.
- ref. proof b/w 9 and 10 stage is much bigger proof stmt.
- nice test to perform, what replacing with is a refinement, good
  because need a soundness thm.
- workshop paper : Attack generation : write in a way that
  characterizes it and points to the oakland paper. short summary. why
  it matters, in intro, then point to paper. paper : on
  modelling. need to be crisp about why we did what we did.
- general temporal theorem.
- higher order : hasn't been released yet.
- a lot of bugs were found by defdata.
- give some examples, of some func. signatures, its very
  beautiful. Being able to concisely represent the types and sigs of
  functions is very useful.
- talk about custom enums. How it helped with testing.

- write a latex version of refinement. define B, and after a step,
  have to be related. if i look at a mesh state, i will have to add
  events to flooding state.

- 1) a high level overview of the kinds of systems considered, trx
  systems in tex, latex, describing B, R, trx relation, all the stuff
  from diss.
  2) ACL2s formalization of 1, with extensive testing
     - create enumerators that guarantee connectivity atleast on the
       mesh side (any two topics that subscribe to FM are in each
       others mesh, paths are unidirectional. Use a worklist algo to
       populate edges.)
       - start with a single topic, add more topics.
  3) keep refining then meet with Pete (if stuck or finish). 
  4) come up with independent dimensions and then prove a refinement
     between that and what I have now. At the top level, we should
     have flooding independent of nbr topics. Prove that what I have
     is a refinement of this. Will have to deal with bisimulation upto
     stuttering. Characterize number of messages that need to be
     sent/data that needs to be sent. Flooding will be faster, same
     number of messages as the mesh. If the number of people
     subscribed is less than a certain number, then flooding is
     faster. In the theorem, there will be a big drop off. Another
     idea : a network that is the most efficient, like a spanning
     tree, in terms of the number of messages sent. If you dynamically
     make changes, but remain connected, then OK. 
  5) We can show that being connected might be sufficient but also
     necessary. For all networks, if not connected then there is no
     refinement thorem. Can show that one can never send a message
     that the other guy gets, idea behind our attacks. In our oakland
     paper, we can get such attacks using gadgets appropriately. 
 
- pubsub send to all.
- mesh only to topics.
- test it.
- won't work unless network is connected, so define enumerators that
  force the network to be connected. 
- 


